##当前消费者的group名称,需要指定  
##消息的消费进度,是根据group来划定的  
group.id=  
##consumer作为zookeeper client,需要通过zk保存一些meta信息,  
##比如consumer消费的消息offset等.  
##必须和broker使用同样的zk配置  
zookeeper.connect=hostname1:port,hostname2:port2  
zookeeper.session.timeout.ms=6000  
zookeeper.connection.timeout.ms=6000  
zookeeper.sync.time.ms=2000  
##当前consumer的标识,可以设定,也可以有系统生成.  
##主要用来跟踪消息消费情况,便于观察  
conusmer.id=  
##获取消息的最大尺寸,broker不会像consumer输出大于此值的消息chunk  
##每次feth将得到多条消息,此值为总大小  
##提升此值,将会消耗更多的consumer端内存  
fetch.messages.max.bytes=1048576  
##broker发送给consumer的最小数据尺寸,如果消息尺寸不足,将会等待,直到满足.  
fetch.min.bytes=1  
##当消息的尺寸不足时,server阻塞的时间,如果超时,消息将立即发送给consumer.  
fetch.wait.max.ms=100  
queued.max.message.chunks=10  
##当有新的consumer加入到group时,将会reblance,此后将会有partitions的消费端迁移到新  
##的consumer上,如果一个consumer获得了某个partition的消费权限,那么它将会向zk注册  
##"Partition Owner registry"节点信息,但是有可能此时旧的consumer尚没有释放此节点,  
##此值用于控制,注册节点的重试次数.  
rebalance.max.retries=4  
##当consumer消费一定量的消息之后,将会自动向zookeeper提交offset信息  
##注意offset信息并不是每消费一次消息就向zk提交一次,而是现在本地保存(内存),并定期提交  
auto.commit.enable=true  
##自动提交的时间间隔,默认为1分钟.  
auto.commit.interval.ms=60*1000